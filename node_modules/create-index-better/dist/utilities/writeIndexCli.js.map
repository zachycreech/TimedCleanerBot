{"version":3,"sources":["../../src/utilities/writeIndexCli.js"],"names":["directoryPaths","options","ext","indexExtension","sortedDirectoryPaths","updateIndex","chalk","green","red","recursive","ignoreUnsafe","extensions","_","map","dir","fileName","silent","flatten","uniq","reverse","join","filter","directoryPath","forEach","existingIndexCode","config","JSON","parse","defaultConfig","siblings","ignoreDirectories","indexFilePath","path","resolve","fs","readFileSync","error","initCode","split","CREATE_INDEX_PATTERN","indexCode","banner","stripExtension","writeFileSync","yellow"],"mappings":"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","file":"writeIndexCli.js","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport _ from 'lodash';\nimport chalk from 'chalk';\nimport createIndexCode from './createIndexCode';\nimport validateTargetDirectory from './validateTargetDirectory';\nimport readDirectory from './readDirectory';\nimport readIndexConfig from './readIndexConfig';\nimport sortByDepth from './sortByDepth';\nimport log from './log';\nimport findIndexFiles from './findIndexFiles';\nimport {CREATE_INDEX_PATTERN} from './constants';\n\nexport default (directoryPaths, options = {}) => {\n  const ext = options.indexExtension || 'js';\n  let sortedDirectoryPaths;\n\n  sortedDirectoryPaths = sortByDepth(directoryPaths);\n\n  log('Target directories', sortedDirectoryPaths);\n  if (options.updateIndex) {\n    log('Update index:', options.updateIndex ? chalk.green('true') : chalk.red('false'));\n  } else {\n    log('Recursive:', options.recursive ? chalk.green('true') : chalk.red('false'));\n    log('Ignore unsafe:', options.ignoreUnsafe ? chalk.green('true') : chalk.red('false'));\n    log('Extensions:', chalk.green(options.extensions));\n  }\n\n  if (options.updateIndex || options.recursive) {\n    sortedDirectoryPaths = _.map(sortedDirectoryPaths, (dir) => {\n      return findIndexFiles(dir, {\n        ext: options.ext,\n        fileName: options.updateIndex ? 'index.' + ext : '*',\n        silent: options.updateIndex || options.ignoreUnsafe\n      });\n    });\n    sortedDirectoryPaths = _.flatten(sortedDirectoryPaths);\n    sortedDirectoryPaths = _.uniq(sortedDirectoryPaths);\n    sortedDirectoryPaths = sortByDepth(sortedDirectoryPaths);\n\n    log('Updating index files in:', sortedDirectoryPaths.reverse().join(', '));\n  }\n\n  sortedDirectoryPaths = sortedDirectoryPaths.filter((directoryPath) => {\n    return validateTargetDirectory(directoryPath, {\n      ext,\n      silent: options.ignoreUnsafe\n    });\n  });\n\n  _.forEach(sortedDirectoryPaths, (directoryPath) => {\n    let existingIndexCode;\n\n    const config = readIndexConfig(directoryPath, ext, JSON.parse(options.defaultConfig || '{}'));\n\n    const siblings = readDirectory(directoryPath, {\n      config,\n      ext,\n      extensions: options.extensions,\n      ignoreDirectories: options.ignoreDirectories,\n      silent: options.ignoreUnsafe\n    });\n\n    const indexFilePath = path.resolve(directoryPath, 'index.' + ext);\n\n    try {\n      existingIndexCode = fs.readFileSync(indexFilePath, 'utf8');\n    } catch (error) {\n      existingIndexCode = '';\n    }\n\n    const initCode = existingIndexCode.split(CREATE_INDEX_PATTERN)[0] || '';\n\n    const indexCode = createIndexCode(siblings, {\n      banner: options.banner,\n      config,\n      stripExtension: options.stripExtension\n    }, initCode);\n\n    fs.writeFileSync(indexFilePath, indexCode);\n\n    if (existingIndexCode && existingIndexCode === indexCode) {\n      log(indexFilePath, chalk.yellow('[index has not changed]'));\n    } else if (existingIndexCode && existingIndexCode !== indexCode) {\n      log(indexFilePath, chalk.green('[updated index]'));\n    } else {\n      log(indexFilePath, chalk.green('[created index]'));\n    }\n  });\n\n  log('Done');\n};\n"]}